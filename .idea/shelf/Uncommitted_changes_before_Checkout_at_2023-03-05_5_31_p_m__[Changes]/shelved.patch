Index: app/src/main/java/com/example/pulmonaryrehabilitation/model_since_2_17/StepCounterClass.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.pulmonaryrehabilitation.model_since_2_17\r\n\r\nimport android.app.Activity\r\nimport android.content.Context\r\nimport android.content.pm.PackageManager\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.core.app.ActivityCompat\r\nimport com.example.pulmonaryrehabilitation.model_database.DatabaseMethod\r\nimport com.google.android.gms.auth.api.signin.GoogleSignIn\r\nimport com.google.android.gms.fitness.Fitness\r\nimport com.google.android.gms.fitness.FitnessOptions\r\nimport com.google.android.gms.fitness.data.DataType\r\nimport com.google.android.gms.fitness.data.Field\r\nimport com.google.firebase.database.FirebaseDatabase\r\nimport java.text.SimpleDateFormat\r\nimport java.util.*\r\n\r\n/**\r\n * This enum is used to define actions that can be performed after a successful sign in to Fit.\r\n * One of these values is passed to the Fit sign-in, and returned in a successful callback, allowing\r\n * subsequent execution of the desired action.\r\n */\r\nenum class FitActionRequestCode {\r\n    SUBSCRIBE,\r\n    READ_DATA\r\n}\r\n\r\nclass StepCounterClass(\r\n    override var context: Context,\r\n) : StepCounter {\r\n    private val fitnessOptions = FitnessOptions.builder()\r\n        .addDataType(DataType.TYPE_STEP_COUNT_CUMULATIVE)\r\n        .addDataType(DataType.TYPE_STEP_COUNT_DELTA)\r\n        .build()\r\n    private val runningQOrLater = android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q\r\n    private val TAG = \"StepCounterClass\"\r\n\r\n    /**\r\n     * Gets a Google account for use in creating the Fitness client. This is achieved by either\r\n     * using the last signed-in account, or if necessary, prompting the user to sign in.\r\n     * `getAccountForExtension` is recommended over `getLastSignedInAccount` as the latter can\r\n     * return `null` if there has been no sign in before.\r\n     */\r\n    private fun getGoogleAccount() = GoogleSignIn.getAccountForExtension(context, fitnessOptions)\r\n\r\n    /**\r\n     * Desc: Getting a user's yesterday's step count using Google Fit's API to send to the Firebase\r\n     *      Realtime Database in the user scope\r\n     * Pre-conditions:\r\n     *      If the user does not have at least one date entry, then this will return an error\r\n     * Post-conditions:\r\n     *      None\r\n     */\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    override fun getYesterdaysStepCount(id: String, database: FirebaseDatabase): String {\r\n        // TODO(Get yesterday's step count)\r\n        // 1. We need to get the current day so we can have a range between today and yesterday\r\n        // 2. We use GoogleFit to extract the step count between the time\r\n        // 3. We parse the data from GoogleFit\r\n        // 4. We send it to the database\r\n\r\n        val dateFormat = SimpleDateFormat(\"MM-dd-yyyy\")\r\n        val calendar = Calendar.getInstance()\r\n        val today = dateFormat.format(calendar.time)\r\n        calendar.add(Calendar.DAY_OF_YEAR, -1) // go back one day\r\n        val yesterday = dateFormat.format(calendar.time)\r\n        val steps = DatabaseMethod().readFromDatabase(\"Member/$id/stepHistory/$yesterday\", database)\r\n        Log.i(TAG, \"Today: $today\")\r\n        Log.i(TAG, \"Yesterday: $yesterday\")\r\n        Log.i(TAG, \"Steps: $steps\")\r\n//        val readRequest =\r\n//            DataReadRequest.Builder()\r\n//                // The data request can specify multiple data types to return,\r\n//                // effectively combining multiple data queries into one call.\r\n//                // This example demonstrates aggregating only one data type.\r\n//                .aggregate(DataType.AGGREGATE_STEP_COUNT_DELTA)\r\n//                // Analogous to a \"Group By\" in SQL, defines how data should be\r\n//                // aggregated.\r\n//                // bucketByTime allows for a time span, whereas bucketBySession allows\r\n//                // bucketing by <a href=\"/fit/android/using-sessions\">sessions</a>.\r\n//                .bucketByTime(1, TimeUnit.DAYS)\r\n//                .setTimeRange(startTime.toEpochSecond(), endTime.toEpochSecond(), TimeUnit.SECONDS)\r\n//                .build()\r\n\r\n        // TODO(Send to Firebase)\r\n        return steps.toString()\r\n    }\r\n\r\n    /**\r\n     * Desc: Getting today's step count by basing off the current data on the application\r\n     * Pre-conditions:\r\n     *      None\r\n     * Post-conditions:\r\n     *      None\r\n     */\r\n    override fun getCurrentDayStepCount(): String {\r\n        // TODO(Get today's step count)\r\n        // 1. Get today's date\r\n        // 2. Use GoogleFit to gather the steps from the application (not the database b/c there is\r\n        //      no current date)\r\n        // 3. Return the steps for today\r\n        Fitness.getHistoryClient(context, getGoogleAccount())\r\n            .readDailyTotal(DataType.TYPE_STEP_COUNT_DELTA)\r\n            .addOnSuccessListener { dataSet ->\r\n                val totalSteps = when {\r\n                    dataSet.isEmpty -> 0\r\n                    else -> dataSet.dataPoints.first().getValue(Field.FIELD_STEPS).asInt()\r\n                }\r\n                Log.i(TAG, \"Total steps: $totalSteps\")\r\n            }\r\n            .addOnFailureListener { e ->\r\n                Log.w(TAG, \"There was a problem getting the step count.\", e)\r\n            }\r\n        return \"\"\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.Q)\r\n    private fun permissionApprove(): Boolean {\r\n        val approve = if (runningQOrLater) {\r\n            PackageManager.PERMISSION_GRANTED == ActivityCompat.checkSelfPermission(\r\n                context,\r\n                android.Manifest.permission.ACTIVITY_RECOGNITION\r\n            )\r\n        } else {\r\n            true\r\n        }\r\n        return approve\r\n    }\r\n\r\n    private fun oAuthPermissionsApproved() = GoogleSignIn.hasPermissions(getGoogleAccount(), fitnessOptions)\r\n\r\n    /**\r\n     * Reads the current daily step total, computed from midnight of the current day on the device's\r\n     * current timezone.\r\n     */\r\n    private fun readData() {\r\n        Fitness.getHistoryClient(context, getGoogleAccount())\r\n            .readDailyTotal(DataType.TYPE_STEP_COUNT_DELTA)\r\n            .addOnSuccessListener { dataSet ->\r\n                val total = when {\r\n                    dataSet.isEmpty -> 0\r\n                    else -> dataSet.dataPoints.first().getValue(Field.FIELD_STEPS).asInt()\r\n                }\r\n                Log.i(TAG, \"Total steps: $total\")\r\n            }\r\n            .addOnFailureListener { e ->\r\n                Log.w(TAG, \"There was a problem getting the step count.\", e)\r\n            }\r\n    }\r\n\r\n    /** Records step data by requesting a subscription to background step data.  */\r\n    private fun subscribe() {\r\n        // To create a subscription, invoke the Recording API. As soon as the subscription is\r\n        // active, fitness data will start recording.\r\n        Fitness.getRecordingClient(context, getGoogleAccount())\r\n            .subscribe(DataType.TYPE_STEP_COUNT_CUMULATIVE)\r\n            .addOnCompleteListener { task ->\r\n                if (task.isSuccessful) {\r\n                    Log.i(TAG, \"Successfully subscribed!\")\r\n                } else {\r\n                    Log.w(TAG, \"There was a problem subscribing.\", task.exception)\r\n                }\r\n            }\r\n    }\r\n\r\n    private fun performActionForRequestCode(requestCode: FitActionRequestCode) = when (requestCode) {\r\n        FitActionRequestCode.READ_DATA -> readData()\r\n        FitActionRequestCode.SUBSCRIBE -> subscribe()\r\n    }\r\n\r\n    /**\r\n     * Checks that the user is signed in, and if so, executes the specified function. If the user is\r\n     * not signed in, initiates the sign in flow, specifying the post-sign in function to execute.\r\n     *\r\n     * @param requestCode The request code corresponding to the action to perform after sign in.\r\n     */\r\n    private fun fitSignIn(requestCode: FitActionRequestCode) {\r\n        if (oAuthPermissionsApproved()) {\r\n            performActionForRequestCode((requestCode))\r\n        } else {\r\n            requestCode.let {\r\n                GoogleSignIn.requestPermissions(\r\n                    context as Activity, requestCode.ordinal, getGoogleAccount(), fitnessOptions\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun requestRuntimePermissions(requestCode: FitActionRequestCode) {\r\n        val shouldProvideRationale = ActivityCompat.shouldShowRequestPermissionRationale(context as Activity, android.Manifest.permission.ACTIVITY_RECOGNITION)\r\n        // Provide an additional rationale to the user. This would happen if the user denied the\r\n        // request previously, but didn't check the \"Don't ask again\" checkbox.\r\n        requestCode.let {\r\n            if (shouldProvideRationale) {\r\n                Log.i(TAG, \"Displaying permission rationale to provide additional context.\")\r\n//                Snackbar.make(\r\n//                    findViewById(R.id.main_activity_view),\r\n//                    R.string.permission_rationale,\r\n//                    Snackbar.LENGTH_INDEFINITE)\r\n//                    .setAction(R.string.ok) {\r\n//                        // Request permission\r\n//                        ActivityCompat.requestPermissions(context as Activity,\r\n//                            arrayOf(android.Manifest.permission.ACTIVITY_RECOGNITION),\r\n//                            requestCode.ordinal)\r\n//                    }\r\n//                    .show()\r\n            } else {\r\n                Log.i(TAG, \"Requesting permission\")\r\n                // Request permission. It's possible this can be auto answered if device policy\r\n                // sets the permission in a given state or the user denied the permission\r\n                // previously and checked \"Never ask again\".\r\n                ActivityCompat.requestPermissions(\r\n                    context as Activity,\r\n                    arrayOf(android.Manifest.permission.ACTIVITY_RECOGNITION),\r\n                    requestCode.ordinal\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.Q)\r\n    override fun checkPermissionsAndRun(fitActionRequestCode: FitActionRequestCode) {\r\n        if (permissionApprove()) {\r\n            fitSignIn(fitActionRequestCode)\r\n        } else {\r\n            requestRuntimePermissions(fitActionRequestCode)\r\n        }\r\n    }\r\n\r\n    private fun oAuthErrorMessage(requestCode: Int, resultCode: Int) {\r\n        val message = \"\"\"\r\n            There was an error signing into Fit. Check the troubleshooting section of the README\r\n            for potential issues.\r\n            Request code was: $requestCode\r\n            Result code was: $resultCode\r\n        \"\"\".trimIndent()\r\n        Log.e(TAG, message)\r\n    }\r\n\r\n//    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n//        super.onActivityResult(requestCode, resultCode, data)\r\n//\r\n//        when (resultCode) {\r\n//            RESULT_OK -> {\r\n//                val postSignInAction = FitActionRequestCode.values()[requestCode]\r\n//                postSignInAction.let {\r\n//                    performActionForRequestCode(postSignInAction)\r\n//                }\r\n//            }\r\n//            else -> oAuthErrorMessage(requestCode, resultCode)\r\n//        }\r\n//    }\r\n\r\n//    override fun onCreateOptionsMenu(menu: Menu): Boolean {\r\n//        // Inflate the main; this adds items to the action bar if it is present.\r\n//        menuInflater.inflate(R.menu.main, menu)\r\n//        return true\r\n//    }\r\n\r\n//    override fun onOptionsItemSelected(item: MenuItem): Boolean {\r\n//        val id = item.itemId\r\n//        if (id == R.id.action_read_data) {\r\n//            fitSignIn(FitActionRequestCode.READ_DATA)\r\n//            return true\r\n//        }\r\n//        return super.onOptionsItemSelected(item)\r\n//    }\r\n\r\n    /** Initializes a custom log class that outputs both to in-app targets and logcat.  */\r\n    private fun initializeLogging() {\r\n//        // Wraps Android's native log framework.\r\n//        val logWrapper = LogWrapper()\r\n//        // Using Log, front-end to the logging chain, emulates android.util.log method signatures.\r\n//        Log.setLogNode(logWrapper)\r\n//        // Filter strips out everything except the message text.\r\n//        val msgFilter = MessageOnlyLogFilter()\r\n//        logWrapper.next = msgFilter\r\n//        // On screen logging via a customized TextView.\r\n//        val logView = findViewById<View>(R.id.sample_logview) as LogView\r\n//        TextViewCompat.setTextAppearance(logView, R.style.Log)\r\n//        logView.setBackgroundColor(Color.WHITE)\r\n//        msgFilter.next = logView\r\n//        Log.i(TAG, \"Ready\")\r\n    }\r\n\r\n    override fun onRequestPermissionsResult(\r\n        requestCode: Int,\r\n        permissions: Array<String>,\r\n        grantResults: IntArray\r\n    ) {\r\n        when {\r\n            grantResults.isEmpty() -> {\r\n                // If user interaction was interrupted, the permission request\r\n                // is cancelled and you receive empty arrays.\r\n                Log.i(TAG, \"User interaction was cancelled.\")\r\n            }\r\n            grantResults[0] == PackageManager.PERMISSION_GRANTED -> {\r\n                // Permission was granted.\r\n                val fitActionRequestCode = FitActionRequestCode.values()[requestCode]\r\n                fitActionRequestCode.let {\r\n                    fitSignIn(fitActionRequestCode)\r\n                }\r\n            }\r\n            else -> {\r\n                // Permission denied.\r\n\r\n                // In this Activity we've chosen to notify the user that they\r\n                // have rejected a core permission for the app since it makes the Activity useless.\r\n                // We're communicating this message in a Snackbar since this is a sample app, but\r\n                // core permissions would typically be best requested during a welcome-screen flow.\r\n\r\n                // Additionally, it is important to remember that a permission might have been\r\n                // rejected without asking the user for permission (device policy or \"Never ask\r\n                // again\" prompts). Therefore, a user interface affordance is typically implemented\r\n                // when permissions are denied. Otherwise, your app could appear unresponsive to\r\n                // touches or interactions which have required permissions.\r\n\r\n//                Snackbar.make(\r\n//                    findViewById(R.id.main_activity_view),\r\n//                    R.string.permission_denied_explanation,\r\n//                    Snackbar.LENGTH_INDEFINITE)\r\n//                    .setAction(R.string.settings) {\r\n//                        // Build intent that displays the App settings screen.\r\n//                        val intent = Intent()\r\n//                        intent.action = Settings.ACTION_APPLICATION_DETAILS_SETTINGS\r\n//                        val uri = Uri.fromParts(\"package\",\r\n//                            BuildConfig.APPLICATION_ID, null)\r\n//                        intent.data = uri\r\n//                        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\r\n//                        startActivity(intent)\r\n//                    }\r\n//                    .show()\r\n            }\r\n        }\r\n    }\r\n\r\n//    /**\r\n//     * Desc: Getting a map collection of all the past recorded step counts\r\n//     * Pre-conditions:\r\n//     *      id: the user's unique ID\r\n//     *      database: Firebase's realtime database\r\n//     * Post-conditions:\r\n//     *      None\r\n//     */\r\n//    override fun getPastStepCount(id: String, database: FirebaseDatabase): String {\r\n//        return DatabaseMethod().readFromDatabase(\"Member/$id/stepHistory\", database).toString()\r\n//    }\r\n}
===================================================================
diff --git a/app/src/main/java/com/example/pulmonaryrehabilitation/model_since_2_17/StepCounterClass.kt b/app/src/main/java/com/example/pulmonaryrehabilitation/model_since_2_17/StepCounterClass.kt
--- a/app/src/main/java/com/example/pulmonaryrehabilitation/model_since_2_17/StepCounterClass.kt	
+++ b/app/src/main/java/com/example/pulmonaryrehabilitation/model_since_2_17/StepCounterClass.kt	
@@ -1,5 +1,6 @@
 package com.example.pulmonaryrehabilitation.model_since_2_17
 
+import android.Manifest
 import android.app.Activity
 import android.content.Context
 import android.content.pm.PackageManager
@@ -34,7 +35,7 @@
         .addDataType(DataType.TYPE_STEP_COUNT_CUMULATIVE)
         .addDataType(DataType.TYPE_STEP_COUNT_DELTA)
         .build()
-    private val runningQOrLater = android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q
+    private val runningQOrLater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q
     private val TAG = "StepCounterClass"
 
     /**
@@ -57,7 +58,7 @@
     override fun getYesterdaysStepCount(id: String, database: FirebaseDatabase): String {
         // TODO(Get yesterday's step count)
         // 1. We need to get the current day so we can have a range between today and yesterday
-        // 2. We use GoogleFit to extract the step count between the time
+        // 2. We use GoogleFit to extract the step count between the timereadRequest
         // 3. We parse the data from GoogleFit
         // 4. We send it to the database
 
@@ -96,6 +97,7 @@
      *      None
      */
     override fun getCurrentDayStepCount(): String {
+        Log.d("sad",oAuthPermissionsApproved().toString())
         // TODO(Get today's step count)
         // 1. Get today's date
         // 2. Use GoogleFit to gather the steps from the application (not the database b/c there is
@@ -121,7 +123,7 @@
         val approve = if (runningQOrLater) {
             PackageManager.PERMISSION_GRANTED == ActivityCompat.checkSelfPermission(
                 context,
-                android.Manifest.permission.ACTIVITY_RECOGNITION
+                Manifest.permission.ACTIVITY_RECOGNITION
             )
         } else {
             true
@@ -189,7 +191,7 @@
     }
 
     private fun requestRuntimePermissions(requestCode: FitActionRequestCode) {
-        val shouldProvideRationale = ActivityCompat.shouldShowRequestPermissionRationale(context as Activity, android.Manifest.permission.ACTIVITY_RECOGNITION)
+        val shouldProvideRationale = ActivityCompat.shouldShowRequestPermissionRationale(context as Activity, Manifest.permission.ACTIVITY_RECOGNITION)
         // Provide an additional rationale to the user. This would happen if the user denied the
         // request previously, but didn't check the "Don't ask again" checkbox.
         requestCode.let {
@@ -213,7 +215,7 @@
                 // previously and checked "Never ask again".
                 ActivityCompat.requestPermissions(
                     context as Activity,
-                    arrayOf(android.Manifest.permission.ACTIVITY_RECOGNITION),
+                    arrayOf(Manifest.permission.ACTIVITY_RECOGNITION),
                     requestCode.ordinal
                 )
             }
